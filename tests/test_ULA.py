import unittest
from pyz80.memorybus import MemoryBus
from pyz80.ULA import *
import mock
import itertools

class TestSpectrumULA(unittest.TestCase):
    def setUp(self):
        self.pixels = {}

        with mock.patch('Tkinter.Tk') as tk:
            with mock.patch('Tkinter.Canvas') as Canvas:
                Canvas.return_value.create_rectangle = lambda *args, **kwargs : (args[0], args[1])
                self.UUT = SpectrumULA()

                Canvas.assert_called_once_with(tk.return_value,
                                                   width=256*self.UUT.scale,
                                                   height=192*self.UUT.scale,
                                                   bg="#000000")
                self.canvas = Canvas.return_value
                tk.return_value.bind.assert_has_calls([ mock.call("<KeyPress>", mock.ANY),
                                                            mock.call("<KeyRelease>", mock.ANY), ])
                bound = { call[1][0] : call[1][1] for call in tk.return_value.bind.mock_calls }
                self.keypress = bound['<KeyPress>']
                self.keyrelease = bound['<KeyRelease>']
        self.canvas.pack.assert_called_once_with()

        self.bus = MemoryBus(mappings=[(0x4000, 0x1B00, self.UUT.display)])

    def test_init(self):
        pass

    def test_read(self):
        for addr in range(0,0x1B00):
            self.bus.write(0x4000 + addr, addr&0xFF)
            self.assertEqual(addr&0xFF, self.bus.read(0x4000 + addr))

    def test_running(self):
        self.assertTrue(self.UUT.running())
        self.UUT.kill()
        self.assertFalse(self.UUT.running())
        self.UUT.window.destroy.assert_called_once_with()

    def assert_write_pixel(self, x, y, bg=0, fg=7, flash=False):
        self.canvas.itemconfigure.reset_mock()
        self.UUT.display.data[0x1800 + (y/8)*32 + (x/8)] = (0x80 if flash else 0x00) + fg + (bg << 3)
        bitval = 1 << (x%8)
        addr = 0x4000 + (x/8) + ((y&0x7) << 8) + ((y&0x38) << 2) + ((y&0xC0) << 5)
        self.bus.write(addr, bitval)

        expected_calls = []
        flip = (flash and (self.UUT.display.flash != 0x00))
        for i in range(0,8):
            if (not flip and ((1 << i) != bitval)) or (flip and ((1 << i) == bitval)):
                expected_calls.append(mock.call((((x/8)*8 + i)*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[bg][0]))
            else:
                expected_calls.append(mock.call((((x/8)*8 + i)*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[fg][0]))
        self.assertItemsEqual(self.canvas.itemconfigure.mock_calls, expected_calls)


    def test_write_pixels(self):
        for y in range(0,192):
            self.assert_write_pixel(255 - y,y)
        for y in range(0,192):
             self.assert_write_pixel(y,y, flash=True)
        self.UUT.display.flash = 0xFF
        for y in range(0,192):
            self.assert_write_pixel((2*y)%256 + int((2*y)/256),y, flash=True)

    def assert_write_attributes(self, x, y, fg=7, bg=0, flash=False):
        self.maxDiff = None
        self.canvas.itemconfigure.reset_mock()
        addr = x + ((y&0x7) << 5) + ((y&0x18) << 8)
        for i in range(0,8):
            self.UUT.display.data[addr] = 0x55
            addr += 0x100

        addr = 0x5800 + (y*32) + x
        self.bus.write(addr, (0x80 if flash else 0x00) + (fg) + (bg << 3))

        expected_calls = []
        for j in range(0,8):
            for i in range(0,4):
                if flash and (self.UUT.display.flash != 0x00):
                    expected_calls.append(mock.call(( (x*8 + 2*i + 1)*self.UUT.scale, (y*8 + j)*self.UUT.scale ), fill=self.UUT.display.pallette[fg][0]))
                    expected_calls.append(mock.call(((x*8 + 2*i + 0)*self.UUT.scale, (y*8 + j)*self.UUT.scale ), fill=self.UUT.display.pallette[bg][0]))
                else:
                    expected_calls.append(mock.call(( (x*8 + 2*i + 1)*self.UUT.scale, (y*8 + j)*self.UUT.scale ), fill=self.UUT.display.pallette[bg][0]))
                    expected_calls.append(mock.call(((x*8 + 2*i + 0)*self.UUT.scale, (y*8 + j)*self.UUT.scale ), fill=self.UUT.display.pallette[fg][0]))
        self.assertItemsEqual(self.canvas.itemconfigure.mock_calls, expected_calls)

    def test_write_attributes(self):
        for y in range(0,24):
            self.assert_write_attributes(y,y)
        for y in range(0,24):
            self.assert_write_attributes(31-y,y, flash=True)
        self.UUT.display.flash = 0xFF
        for y in range(0,24):
            self.assert_write_attributes((2*y)%32 + int((2*y)/32),y, flash=True)

    def test_update(self):
        with mock.patch('pyz80.ULA.time', return_value=self.UUT.display.last_flash + 1):
            self.UUT.update()
        self.UUT.window.update_idletasks.assert_called_once_with()
        self.UUT.window.update.assert_called_once_with()

    def test_flash(self):
        self.UUT.display.data[0x1800] = 0x87
        for j in range(0,8):
            self.UUT.display.data[j*0x100] = 0x55

        with mock.patch('pyz80.ULA.time', side_effect=lambda : self.UUT.display.last_flash + 1):
            self.UUT.update()

        expected_calls = []
        for y in range(0,8):
            for x in range(0,4):
                expected_calls.append(mock.call(( 2*x*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[0][0]))
                expected_calls.append(mock.call(( (2*x + 1)*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[7][0]))
        self.assertItemsEqual(expected_calls, self.canvas.itemconfigure.mock_calls)

        self.canvas.itemconfigure.reset_mock()
        with mock.patch('pyz80.ULA.time', side_effect=lambda : self.UUT.display.last_flash):
            self.UUT.update()

        self.canvas.itemconfigure.assert_not_called()

        self.canvas.itemconfigure.reset_mock()
        with mock.patch('pyz80.ULA.time', side_effect=lambda : self.UUT.display.last_flash + 1):
            self.UUT.update()

        expected_calls = []
        for y in range(0,8):
            for x in range(0,4):
                expected_calls.append(mock.call(( 2*x*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[7][0]))
                expected_calls.append(mock.call(( (2*x + 1)*self.UUT.scale, y*self.UUT.scale), fill=self.UUT.display.pallette[0][0]))
        self.assertItemsEqual(expected_calls, self.canvas.itemconfigure.mock_calls)

    def test_description(self):
        self.assertIsInstance(self.UUT.display.description(), basestring)

    def test_responds_to_port(self):
        for i in range(0,128):
            self.assertTrue(self.UUT.io.responds_to_port(2*i))
            self.assertFalse(self.UUT.io.responds_to_port(2*i + 1))

    def test_keyboard_matrix(self):
        LSH = 131074
        RSH = 131076
        PND = u'\xa3'
        NTR = '\r'
        test_data = [
            [ [],    [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['q'], [],    [ 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['q'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['w'], [],    [ 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['w'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['e'], [],    [ 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['e'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['r'], [],    [ 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['r'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['t'], [],    [ 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['t'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['y'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF ]],
            [ [],    ['y'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['u'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF ]],
            [ [],    ['u'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['i'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF ]],
            [ [],    ['i'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['o'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF ]],
            [ [],    ['o'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['p'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF ]],
            [ [],    ['p'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['a'], [],    [ 0xFF, 0xfe, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['a'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['s'], [],    [ 0xFF, 0xfd, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['s'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['d'], [],    [ 0xFF, 0xfb, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['d'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['f'], [],    [ 0xFF, 0xf7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['f'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['g'], [],    [ 0xFF, 0xef, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['g'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['h'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF ]],
            [ [],    ['h'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['j'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF ]],
            [ [],    ['j'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['k'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF ]],
            [ [],    ['k'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['l'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF ]],
            [ [],    ['l'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [NTR], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF ]],
            [ [],    [NTR], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [LSH], [],    [ 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    [LSH], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['z'], [],    [ 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['z'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['x'], [],    [ 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['x'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['c'], [],    [ 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['c'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['v'], [],    [ 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['v'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['b'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ,0xFF, 0xEF ]],
            [ [],    ['b'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['n'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ,0xFF, 0xF7 ]],
            [ [],    ['n'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['m'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ,0xFF, 0xFB ]],
            [ [],    ['m'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [RSH], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ,0xFF, 0xFD ]],
            [ [],    [RSH], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [' '], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ,0xFF, 0xFE ]],
            [ [],    [' '], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['0'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['0'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['1'], [],    [ 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['1'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['2'], [],    [ 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['2'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['3'], [],    [ 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['3'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['4'], [],    [ 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['4'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['5'], [],    [ 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['5'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['6'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['6'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['7'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['7'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['8'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['8'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['9'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['9'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [')'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF ]],
            [ [],    [')'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['!'], [],    [ 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['!'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['@'], [],    [ 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['@'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [PND], [],    [ 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    [PND], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['$'], [],    [ 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['$'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['%'], [],    [ 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['%'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['^'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['^'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['&'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['&'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['*'], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['*'], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            [ ['('], [],    [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF ]],
            [ [],    ['('], [ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]],
            ]

        for data in test_data:
            for key in data[0]:
                m = mock.MagicMock()
                if isinstance(key, basestring):
                    m.char = key
                else:
                    m.char = ''
                    m.keycode = key
                self.keypress(m)
            for key in data[1]:
                m = mock.MagicMock()
                if isinstance(key, basestring):
                    m.char = key
                else:
                    m.char = ''
                    m.keycode = key
                self.keyrelease(m)
            for a in range(0,8):
                addr = 0xFF - (1 << a)
                x = self.UUT.io.read(addr)
                self.assertEqual(x, data[2][a], msg="""\
Failed to match output at 0x%02X when keys set are %r and keys unset are %r. Got 0x%02X, expected 0x%02X.\
""" % (addr, data[0], data[1], x, data[2][a]))

            for l in itertools.product(*[range(0,8) for _ in range(0,2)]):
                address = 0x00
                expected = 0xFF
                for n in l:
                    address |= 1 << n
                    expected &= self.UUT.io.read(0xFF - (1 << n))
                address = 0xFF - address
                self.assertEqual(self.UUT.io.read(address), expected)

    def test_io_write(self):
        for addr in range(0,256):
            self.UUT.io.write(addr, 0x00)
            self.assertEqual(self.UUT.io.read(addr), 0xFF)

